// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: words.sql

package database

import (
	"context"
)

const createWord = `-- name: CreateWord :one
INSERT INTO words (id, word)
VALUES (
    DEFAULT, 
    $1
) 
RETURNING id, word
`

func (q *Queries) CreateWord(ctx context.Context, word string) (Word, error) {
	row := q.db.QueryRowContext(ctx, createWord, word)
	var i Word
	err := row.Scan(&i.ID, &i.Word)
	return i, err
}

const getIDByWord = `-- name: GetIDByWord :one
SELECT id FROM words WHERE word=$1
`

func (q *Queries) GetIDByWord(ctx context.Context, word string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getIDByWord, word)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getWordsWithLenInRangeSorted = `-- name: GetWordsWithLenInRangeSorted :many
SELECT word FROM words WHERE CHAR_LENGTH(word) BETWEEN $1 AND $2 ORDER BY word ASC
`

type GetWordsWithLenInRangeSortedParams struct {
	Minlen string
	Maxlen string
}

func (q *Queries) GetWordsWithLenInRangeSorted(ctx context.Context, arg GetWordsWithLenInRangeSortedParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getWordsWithLenInRangeSorted, arg.Minlen, arg.Maxlen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var word string
		if err := rows.Scan(&word); err != nil {
			return nil, err
		}
		items = append(items, word)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
